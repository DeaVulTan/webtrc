/**
 @module rtcSession
 */
"use strict";

/**

 @class
     An RtcSession instance handles all jingle and webRTC operations
 for the Strophe connection object on which it was created, i.e. it
 adds webRTC support for that connection.
 To perform media calls, call its methods.
 To handle events generated by it, attach handlers to it.
 All events are called on the RtcSession
 instance and, since this object is not a DOM object, no bubbling will occur.
 Therefore, you should attach all event handlers to the RTC session instance.
 The handlers are called with the RtcSession instance as the <i>this</i> object.
 @param {Strophe.connection} stropheConn
 The Strophe connection object to add Jingle/webRTC support to
 @param {object} options
 Configuration options
 @param {object[]} [options.iceServers]
 An array of objects, each describing a TURN or STUN server, like so:
 [{url: 'stun:stun.l.google.com:19302'}]
 If none is specified, NAT won't be traversed.
 @param {function} options.encryptMessageForJid
 A function to encrypt the local SRTP fingerprint(or any other message)
 with the specified bare JID's public key. The function's signature is
 <i> encryptMessageForJid(msg:string, bareJid: string): string </i>
 It returns the encrypted message encoded in a string. If there is an error, the
 function must throw an exception
 @param {function} options.decryptMessage
 A function that does the reverse of encryptMessageForJid() - given the
 message, encrypted by that function, encrypted for us (with our public key),
 decrypts it with our private key and returns it.
 The function signature is <i>decryptMessage(msg:string): string</i>
 If there was an error, the function must throw an exception
 @param {function} options.generateMac
 A function that takes a message and a key and returns a MAC. Can be any
 standard MAC function such as hmac-sha1 or similar
 Signature: <i> generateMac(msg:string, key:string):string
 If there is an error, the function must throw an exception
 @param {function} [options.generateMacKey]
 A function that generates a new, unpredictably random, never-used-before
 mac key, used to verify certificate fingerprints.
 If it is not provided, a built-in implementation is used that utilizes
 crypto.getRandomValues() to generate a 256-bit (32-byte, 8-int) key,
 encoding in base64 format.
 The function takes no parameters and returns the generated string.
 @param {function} [options.prepareToSendMessage]
 A function that prepares to send the first message when initiating
 a session. It takes two parameters (sendmsg, jid), where sendmsg is a
 0-argument function "sendmsg", and jid is the targetJid.
 If this is not provided, function(sendmsg, jid) { sendmsg(); } is used,
 which executes it immediately.
 @returns {RtcSession}
 */

function RtcSession(stropheConn, options) {
    if (!RTC)
        throw new Error('This browser does not support webRTC');

    this.connection = stropheConn;
    this.jingle = stropheConn.jingle;
    var jingle = this.jingle;
    if (jingle.rtcSession)
        throw new Error("This Strophe connection already has an associated RtcSession instance");
// Init crypto functions
    if (!options.encryptMessageForJid || !options.decryptMessage || !options.generateMac) {
        if (options.dummyCryptoFunctions) {
            jingle.encryptMessageForJid = function(msg, bareJid)
            {return RtcSession.xorEnc(msg, bareJid)};
            jingle.decryptMessage = function(msg)
            {return RtcSession.xorDec(msg, Strophe.getBareJidFromJid(this.connection.jid))};
            jingle.generateMac = function(msg, key)
            {return RtcSession.xorEnc(msg, key)};
        } else
            throw new Error("At least one crypto function is not provided in 'options'");
    } else {
        jingle.encryptMessageForJid = options.encryptMessageForJid;
        jingle.decryptMessage = options.decryptMessage;
        jingle.generateMac = options.generateMac;
        jingle.generateMacKey = options.generateMacKey;
    }
    if (options.generateMacKey) {
        jingle.generateMacKey = options.generateMacKey;
    } else {
        jingle.generateMacKey = function() {
            var array = new Uint8Array(32);
            var result = '';
            window.crypto.getRandomValues(array);
            for (var i=0; i<32; i++)
                result+=String.fromCharCode(array[i]);
            return btoa(result);
        }
    }
    if (options.prepareToSendMessage) {
        jingle.prepareToSendMessage = options.prepareToSendMessage;
    } else {
        jingle.prepareToSendMessage = function(f) { f(); };
    }
    jingle.verifyMac = function(msg, key, actualMac) {
        if (!actualMac)
            return false;
        var expectedMac;
        try {
            expectedMac = jingle.generateMac(msg, key);
        } catch(e) {
            return false;
        }

        // constant-time compare
        var aLen = actualMac.length;
        var eLen = expectedMac.length;
        var match = (aLen === eLen);
        for (var i=0; i < Math.min(aLen, eLen); i++) {
            match &= (expectedMac.charCodeAt(i) === actualMac.charCodeAt(i));
        };
        return match;
    };
//===
    this.iceConfig = options.iceServers?options.iceServers:null;
    this.options = options;
    this.audioMuted = false;
    this.videoMuted = false;
    this.PRANSWER = false; // use either pranswer or autoaccept

    stropheConn.jingle.rtcSession = this; //needed to access the RtcSession object from jingle event handlers
//muc stuff
    this.myroomjid = null;
    this.roomjid = null;
    this.list_members = [];
//===
    this.jingle.onConnectionEvent = this.onConnectionEvent;
    var self = this;
    if (RtcSession.RAWLOGGING)
    {
        this.connection.rawInput = function (data)
        { if (RtcSession.RAWLOGGING) console.log('RECV: ' + data); };
        this.connection.rawOutput = function (data)
        { if (RtcSession.RAWLOGGING) console.log('SEND: ' + data); };
    }

    if (options.iceServers)
        this.jingle.ice_config = {iceServers:options.iceServers};
    this.jingle.pc_constraints = RTC.pc_constraints;

    var j = this.jingle;

    j.eventHandler = this; //all callbacks will be called with this == eventHandler
    j.onIncomingCallRequest = this.onIncomingCallRequest;
    /**
     Fired when the incoming call request is not longer valid. This may happen for the reasons stated below,
     and the reason is specified in the info.event property: <br>
     1) Cancened by caller. info.event='canceled' <br>
     2) Handled by another resource (i.e. client). info.event='handled-elsewhere' <br>
     3) Call was not handled by anybody for a certain time, <br>
     even without the caller sending a cancel message. info.event='timeout'
     @event "call-canceled"
     @type {object}
     @property {string} from
     The full JID from which the call originated
     @property {object} info Additional details
     @property {string} info.event
     The reason why the call request is not valid anymore
     @property {boolean} [info.answered]
     Only if event='handled-elsewhere'. <i>true</i> if the call was answered by that other resource, of <i>false</i> if the call was declined by it
     @property {string} [info.by]
     Only if event='handled-elsewhere'. The full JID that handled the call
     */
    j.onCallCanceled = function(from, info) {self.trigger('call-canceled', {from:from, info:info});};
    j.onCallAnswered = this.onCallAnswered;
    j.onCallTerminated = this.onCallTerminated;
    j.onRemoteStreamAdded = this.onRemoteStreamAdded;
    j.onRemoteStreamRemoved = this.onRemoteStreamRemoved;
    j.onNoStunCandidates = this.noStunCandidates;
    j.onJingleError = this.onJingleError;
    j.onMuted = function(sess, info) {
        /**
         Fired when the remote peer muted a stream
         @event "muted"
         @type {object}
         @property {object} info
         @property {boolean} [info.audio] Present and equals to <i>true</i> if audio was muted
         @property {boolean} [info.video] Present and equals to <i>true</i> if video was muted
         @property {SessWrapper} sess
         The session on which the event occurred
         */
        this.trigger('muted', {info:info, sess: new SessWrapper(sess)});
    }
    j.onUnmuted = function(sess, info) {
        /**
         Fired when the remote peer unmuted a stream
         @event "unmuted"
         @type {object}
         @property {object} info
         @property {boolean} [info.audio] Present and equals to <i>true</i> if audio was muted
         @property {boolean} [info.video] Present and equals to <i>true</i> if video was muted
         @property {SessWrapper} sess
         The session on which the event occurred
         */

        this.trigger("unmuted", {info:info, sess: new SessWrapper(sess)});
    }

    if (RTC.browser == 'firefox')
        this.jingle.media_constraints.mandatory.MozDontOfferDataChannel = true;
};
//global variables
//RtcSession.gLocalAudioOnlyStream = {stream: null, refcount:0};
//RtcSession.gLocalAudioVideoStream = {stream: null, refcount:0};

RtcSession.gLocalStream = null;
RtcSession.gLocalVid = null;
RtcSession.gVolMon = null;
RtcSession.gVolMonCallback = null;

RtcSession.prototype = {
    NO_DTLS: false, //compat with android
    _myGetUserMedia: function(options, successCallback, errCallback)
    {
        var self = this;
        if (RtcSession.gLocalStream)
        {
            var sessStream = RTC.cloneMediaStream(RtcSession.gLocalStream, {audio:true, video:true});
            self._refLocalStream(options.video);
            successCallback.call(self, sessStream);
            return;
        }

        RTC.getUserMediaWithConstraintsAndCallback({audio: true, video: true}, this,
            function(stream) {
                RtcSession.gLocalStream = stream;
                RtcSession.gLocalStreamRefcount = 0;
                var sessStream = RTC.cloneMediaStream(RtcSession.gLocalStream, {audio:true, video:true});
                self._onMediaReady(RtcSession.gLocalStream);
                self._refLocalStream(options.video);
                successCallback.call(self, sessStream);
            },
            function(error, e) {
                var msg;
                if (!error)
                    msg = e;
                else {
                    if (typeof error === 'string')
                        msg = error;
                    else if (error.name)
                        msg = error.name;
                    else if (error.code)
                        msg = error.code;
                    else
                        msg = error;
                }
                if (errCallback)
                    errCallback(msg);
                /**
                 Fired when there was an error getting the media stream from the local camera/mic
                 @event "local-media-fail"
                 @type object
                 @property {string} error
                 The error message
                 */
                self.trigger('local-media-fail', {error:msg});
            });
    },

    onConnectionEvent: function(status, condition)
    {
//WARNING: called directly by Strophe, with this == connection.jingle
        switch (status)
        {
            case Strophe.Status.CONNFAIL:
            case Strophe.Status.DISCONNECTING:
            {
                this.terminateAll('disconnected', null, true);
                this.rtcSession._freeLocalStream();
                break;
            }
            case Strophe.Status.CONNECTED:
            {
                this.connection.addHandler(RtcSession.prototype._onPresenceUnavailable.bind(this.rtcSession),
                    null, 'presence', 'unavailable', null, null);
                this.getStunAndTurnCredentials();
                break;
            }
        }
    },

    /**
     Initiates a media call to the specified peer
     @param {string} targetJid
     The JID of the callee. Can be a full jid (including resource),
     or a bare JID (without resource), in which case the call request will be broadcast
     using a special <message> packet. For more details on the call broadcast mechanism,
     see the Wiki
     @param {MediaOptions} options Call options
     @param {boolean} options.audio Send audio
     @param {boolean} options.video Send video
     @param {string} [myJid]
     Necessary only if doing MUC, because the user's JID in the
     room is different than her normal JID. If not specified,
     the user's 'normal' JID will be used
     @returns {{cancel: function()}}
     Returns an object with a cancel() method, that, when called, cancels the call request.
     This method returns <i>true</i> if the call was successfully canceled, and <i>false</i>
     in case the call was already answered by someone.
     */

    startMediaCall: function(targetJid, options, myJid)
    {
        var ansHandler = null;
        var declineHandler = null;
        var state = 0; //state 0 means not yet got usermedia, 1 means got user media and waiting for peer, state 2 means pear answered or timed out, 4 means call was canceled by us via the cancel() method of the returned object
        var self = this;
        var isBroadcast = (!Strophe.getResourceFromJid(targetJid));
        var ownFprMacKey = this.jingle.generateMacKey();

        self._myGetUserMedia(options,
            function(sessStream) {
                if (state === 4) {//call was canceled before we got user media
                    self._freeLocalStreamIfUnused();
                    return;
                }
                state = 1;
// Call accepted handler
                ansHandler = this.connection.addHandler(function(stanza) {
                    try {
                        if (state !== 1)
                            return;
                        state = 2;
                        self.connection.deleteHandler(declineHandler);
                        declineHandler = null;
                        ansHandler = null;
// The crypto exceptions thrown here will simply discard the call request and remove the handler
                        var peerFprMacKey = $(stanza).attr('fprmackey');
                        try {
                            peerFprMacKey = self.jingle.decryptMessage(peerFprMacKey);
                            if (!peerFprMacKey)
                                peerFprMacKey = self.jingle.generateMacKey();
                        } catch(e) {
                            peerFprMacKey = self.jingle.generateMacKey();
                        }

                        var fullPeerJid = $(stanza).attr('from');
                        if (isBroadcast)
                            self.connection.send($msg({to:Strophe.getBareJidFromJid(targetJid), type: 'megaNotifyCallHandled', by: fullPeerJid, accepted:'1'}));

                        self.jingle.initiate(fullPeerJid, myJid ? myJid:self.connection.jid,
                            sessStream, RtcSession.mediaOptionsToMutedState(options, sessStream),
                            {ownFprMacKey: ownFprMacKey, peerFprMacKey: peerFprMacKey});
                        /**
                         An outgoing call is being initiated by us
                         @event "call-init"
                         @type {object}
                         @property {string} peer
                         The full JID of the remote peer, to whom the call is being made
                         */
                        self.trigger('call-init', {peer:fullPeerJid});
                    } catch(e) {
                        self._freeLocalStreamIfUnused();
                        console.error("Exception in call answer handler:\n"+e.stack+'\nIgnoring call');
                    }
                }, null, 'message', 'megaCallAnswer', null, targetJid, {matchBare: true});

//Call declined handler
                declineHandler = this.connection.addHandler(function(stanza) {
                        if (state !== 1)
                            return;

                        state = 2;
                        self.connection.deleteHandler(ansHandler);
                        ansHandler = null;
                        declineHandler = null;
                        sessStream = null;
                        self._freeLocalStreamIfUnused();

                        var body = stanza.getElementsByTagName('body');
                        var fullPeerJid = $(stanza).attr('from');

                        if (isBroadcast)
                            self.connection.send($msg({to:Strophe.getBareJidFromJid(targetJid), type: 'megaNotifyCallHandled', by: fullPeerJid, accepted:'0'}));
                        /**
                         A call that we have initiated has been declined by the remote peer
                         @event "call-declined"
                         @type {object}
                         @property {string} from
                         The full JID of the peer that declined the call
                         @property {string} reason
                         The short(one word) reason that the remote specified for declining the call.
                         If the remote user didn't explicitly specify one, the default is 'busy'
                         @property {string} [text]
                         Optional verbose message specifying the reason
                         why the remote declined the call. Can be an error message
                         */
                        self.trigger('call-declined', {
                            peer: fullPeerJid,
                            reason: $(stanza).attr('reason'),
                            text : body.length ? RtcSession.xmlUnescape(body[0].textContent) : undefined
                        });
                    },
                    null, 'message', 'megaCallDecline', null, targetJid, {matchBare: true});

                self.jingle.prepareToSendMessage(function() {
                    self.connection.send($msg({
                        to:targetJid,
                        type:'megaCall',
                        fprmackey: self.jingle.encryptMessageForJid(ownFprMacKey, targetJid)
                    }));
                }, targetJid);

                setTimeout(function() {
                    if (state !== 1)
                        return;

                    state = 2;
                    self.connection.deleteHandler(ansHandler);
                    ansHandler = null;
                    self.connection.deleteHandler(declineHandler);
                    declineHandler = null;
                    sessStream = null;
                    self._freeLocalStreamIfUnused();

                    self.connection.send($msg({to:Strophe.getBareJidFromJid(targetJid), type: 'megaCallCancel'}));
                    /**
                     A call that we initiated was not answered (neither accepted nor rejected)
                     within the acceptable timeout.
                     @event "call-answer-timeout"
                     @type {object}
                     @property {string} peer The JID of the callee
                     */
                    self.trigger('call-answer-timeout', {peer: targetJid});
                }, self.jingle.callAnswerTimeout);
            }); //end myGetUserMedia()

        //return an object with a cancel() method
        return {cancel: function() {
            if (state === 2)
                return false;
            if (state === 1) { //same as if (ansHandler)
                state = 4;
                self.connection.deleteHandler(ansHandler);
                ansHandler = null;
                self.connection.deleteHandler(declineHandler);
                declineHandler = null;

                self._freeLocalStreamIfUnused();
                self.connection.send($msg({to:Strophe.getBareJidFromJid(targetJid), type: 'megaCallCancel'}));
                return true;
            } else if (state === 0) {
                state = 4;
                return true;
            }
            console.warn("RtcSession: BUG: cancel() called when state has an unexpected value of", state);
            return false;
        }};
    },

    /**
     Terminates an ongoing call
     @param {string} [fullJid]
     The full JID of the peer, serves to identify the call. If no jid is specified,
     all current calls are terminated
     */
    hangup: function(jid)
    {
        if (jid) {
            this.jingle.terminateByJid(jid, 'hangup');
            this.jingle.cancelAutoAnswerEntry(jid, 'hangup', '');
        } else {
            this.jingle.terminateAll('hangup');
            this.jingle.cancelAllAutoAnswerEntries('hangup', '');
        }
    },

    /**
     Mutes/unmutes audio/video
     @param {boolean} state
     Specifies whether to mute or unmute:
     <i>true</i> mutes,  <i>false</i> unmutes.
     @param {object} what
     Determine whether the (un)mute operation applies to audio and/or video channels
     @param {boolean} [what.audio] The (un)mute operation is applied to the audio channel
     @param {boolean} [what.video] The (un)mute operation is applied to the video channel
     @param {string} [jid]
     If given, specifies that the mute operation will apply only
     to the call to the given JID. If not specified,
     the (un)mute will be applied to all ongoing calls.
     */
    muteUnmute: function(state, what, jid)
    {
        var sessions = this._getSessionsForJid(jid);
        if (!sessions)
            return false;
// If we are muting all calls, disable also local video playback as well
// In Firefox, all local streams are only references to gLocalStream, so muting any of them
// mutes all and the local video playback.
// In Chrome all local streams are independent, so the local video stream has to be
// muted explicitly as well
        if (what.video && (!jid || (sessions.length >= RtcSession.gLocalStreamRefcount))) {
            if (state)
                RtcSession._disableLocalVid(this);
            else
                RtcSession._enableLocalVid(this);
        }
        for (var i=0; i<sessions.length; i++)
            sessions[i].muteUnmute(state, what);
        return true;
    },
    _getSessionsForJid: function(jid) {
        var sessions = [];
        if (!jid) {
            for (var k in this.jingle.sessions)
                sessions.push(this.jingle.sessions[k]);
            if (sessions.length < 1)
                return null;
        } else {
            jid = Strophe.getBareJidFromJid(jid);
            for(var j in this.jingle.jid2session)
                if (Strophe.getBareJidFromJid(j) == jid)
                    sessions.push(this.jingle.jid2session[j]);
        }
        return sessions;
    },
    _onPresenceUnavailable: function(pres)
    {
        try {
            this.jingle.terminateByJid($(pres).attr('from'), 'peer-disconnected');
        } catch(e) {
            console.error("_onPresenceUnavailable: Exception in handler:", e.stack);
        }
        return true; //We dont want this handler to be deleted
    },

    _onMediaReady: function(localStream) {
// localStream is actually RtcSession.gLocalStream

        for (var i = 0; i < localStream.getAudioTracks().length; i++)
            console.log('using audio device "' +localStream.getAudioTracks()[i].label + '"');

        for (i = 0; i < localStream.getVideoTracks().length; i++)
            console.log('using video device "' + localStream.getVideoTracks()[i].label + '"');

        // mute video on firefox and recent canary
        var elemClass = "localViewport";
        if (localStream.getVideoTracks().length < 1)
            elemClass +=" localNoVideo";

        if (RtcSession.gLocalVid)
            throw new Error("Local stream just obtained, but localVid was not null");

        var vid = $('<video class="'+elemClass+'" autoplay="autoplay" />');
        if (vid.length < 1)
            throw new Error("Failed to create local video element");
        vid = vid[0];
        vid.muted = true;
        vid.volume = 0;
        RtcSession.gLocalVid = vid;
        /**
         Local media stream has just been opened and a video element was
         created (the player param), but not yet added to the DOM. The stream object
         is a MediaStream interface object defined by the webRTC standard.
         This is the place to customize the player before it is shown. Also, this is the
         place to attach a mic volume callback, if used, via volMonAttachCallback().
         The callback will start being called just after the video element is shown.
         @event "local-stream-obtained"
         @type {object}
         @property {object} stream The local media stream object
         @property {DOM} player
         The video DOM element that displays the local video. <br>
         The video element will have the <i>localViewport</i> class.
         If the user does not have a camera, (only audio), the
         element will also have the localNoVideo CSS class.
         However, if the user has camera, event if he doesn't send video, local
         video will be displayed in the local player, and the local player will not have
         the <i>localNoVideo<i> class
         */
        this.trigger('local-stream-obtained', {stream: localStream, player: vid});
        RtcSession._maybeCreateVolMon();
    },

    onIncomingCallRequest: function(from, reqStillValid, ansFunc)
    {
        var self = this;
        /**
         Incoming call request received
         @event "call-incoming-request"
         @type {object}
         @property {string} from
         The full JID of the caller
         @property {ReqValidFunc} reqStillValid
         A function returning boolean that can be used at any time to check if the call request is still
         valid (i.e. not timed out)
         @property {AnswerFunc} answer
         A function to answer or decline the call
         */
        this.trigger('call-incoming-request', {peer: from, reqStillValid: reqStillValid, answer:
            function(accept, obj) {
                if (!reqStillValid()) //expired
                    return false;

                if (!accept)
                    return ansFunc(false, {reason: obj.reason?obj.reason:'busy', text: obj.text});

                self._myGetUserMedia(obj.mediaOptions, //{audio:true, video:true},
                    function(sessStream) {
                        ansFunc(true, {
                            options:{
                                localStream: sessStream,
                                muted: RtcSession.mediaOptionsToMutedState(obj.mediaOptions, sessStream)
                            }
                        });
                    },
                    function(err) {
                        ansFunc(false, {reason: 'error', text: "There was a problem accessing user's camera or microphone. Error: "+err});
                    });

                return true;
            }});
        /**
         Function parameter to <i>call-incoming-request</i> to check if the call request is still valid
         @callback ReqValidFunc
         @returns {boolean}
         */

        /**
         Function parameter to <i>call-incoming-request</i> to answer or decline the call
         @callback AnswerFunc
         @param {boolean} accept Specifies whether to accept (<i>true</i>) or decline (<i>false</i>) the call
         @param {object} obj Options that depend on whether the call is to be acceped or declined
         @param {string} [obj.reason] If call declined: The one-word reason why the call was declined
         If not specified, defaults to 'busy'
         @param {string} [obj.text] If call declined: The verbose text explaining why the call was declined.
         Can be an error message
         @param {MediaOptions} [obj.mediaOptions] If call accepted: The same options that are used in startMediaCall()
         @returns {boolean}
         Returns <i>false</i> if the call request has expired, <i>true</i> otherwise
         */
    },

    onCallAnswered: function(info) {
        /**
         An incoming call has been answered
         @event "call-answered"
         @type {object}
         @property {string} peer The full JID of the remote peer that called us
         */
        this.trigger('call-answered', info);
    },

    removeVideo: function(sess) {
        /**
         The media session with peer JID has been destroyed, and the video element
         has to be removed from the DOM.
         @event "remote-player-remove"
         @type object
         @property {string} id The id of the html video element to be removed
         @property {SessWrapper} sess
         */
        this.trigger('remote-player-remove', {id: '#remotevideo_'+sess.sid, sess:new SessWrapper(sess)});
    },

    onMediaRecv: function(playerElem, sess, stream) {
        if (!this.jingle.sessionIsValid(sess)) {
            this.error("onMediaRecv received for non-existing session:", sid)
            return;
        }
        /**
         Triggered when actual media packets start being received from <i>peer</i>,
         on session <i>sess</i>. The video DOM element has just been created, and is passed as the
         player property.
         @event "media-recv"
         @type {object}
         @property {string} peer The full JID of the peer
         @property {SessWrapper} sess The session
         @property {MediaStream} stream The remote media stream
         @property {DOM} player
         The video player element that has just been created for the remote stream.
         The element will always have the rmtViewport CSS class.
         If there is no video received, but only audio, the element will have
         also the rmtNoVideo CSS class.
         <br>NOTE: Because video is always negotiated if there is a camera, even if it is not sent,
         the rmt(No)Video is useful only when the peer does not have a camera at all,
         and is not possible to start sending video later during the call (for desktop
         sharing, the call has to be re-established)
         */
        var obj = {peer: sess.peerjid, sess:new SessWrapper(sess), stream: stream, player: playerElem};
        this.trigger('media-recv', obj);
        if (obj.stats && RTC.Stats) {
            var s = obj.stats;
            if (!s.scanPeriod || !s.maxSamplePeriod)
                return;
            sess.statsRecorder = new RTC.Stats.Recorder(sess, s.scanPeriod, s.maxSamplePeriod, s.onSample);
            sess.statsRecorder.start();
        }
        else
            sess.tsMediaStart = Date.now();
    },

    onCallTerminated: function(sess, reason, text) {
        try {
            //WARNING: sess may be a dummy object, only with peerjid property, in case something went
            //wrong before the actual session was created, e.g. if SRTP fingerprint verification failed

            /**
             Call was terminated, either by remote peer or by us
             @event "call-ended"
             @type {object}
             @property {string} peer The remote peer's full JID
             @property {SessWrapper} sess The session of the call
             @property {string} [reason] The reason for termination of the call
             @property {string} [text]
             The verbose reason or error message for termination of the call
             @property {object} [stats]
             The statistics gathered during the call, if stats were enabled
             @property {object} [basicStats]
             In case statistics are not available on that browser, or were not enabled,
             this property is set and contains minimum info about the call that can be
             used by a stats server
             @property {string} basicStats.callId
             The callId that the statistics engine would provide
             @property {number} basicStats.callDur
             The duration of actual media in seconds (ms rounded via Math.ceil()) that
             the stats engine would have provided
             */
            var obj = {
                peer: sess.peerjid,
                sess: new SessWrapper(sess), //can be a dummy session but the wrapper will still work
                reason:reason, text:text
            };
            if (sess.statsRecorder)  {
                var stats = obj.stats = sess.statsRecorder.terminate(RtcSession._makeCallId(sess));
                stats.isCaller = sess.isInitiator?1:0;
                stats.termRsn = reason;
            }
            else { //no stats, but will still provide callId and duration
                var bstats = obj.basicStats = {
                    isCaller: sess.isInitiator?1:0,
                    termRsn: reason,
                    bws: RTC.browser.charAt(0)+(navigator.userAgent.match(/(Android|iPhone)/i)?'m':'')
                };
                if (sess.sid) {
                    if (sess.fake)
                        sess.me = this.jid; //makeCallId needs 'me' as well
                    bstats.cid = RtcSession._makeCallId(sess);
                }
                else
                    bstats.cid = RtcSession._makeCallId({
                        peerjid: sess.peerjid, me: this.jid, isInitiator: sess.isInitiator,
                        sid: "_fake:"+Math.random().toString(36).substr(2, 10)
                    });
                if (sess.tsMediaStart) {
                    bstats.ts = Math.round(sess.tsMediaStart/1000);
                    bstats.dur = Math.ceil((Date.now()-sess.tsMediaStart)/1000);
                }
            }
            this.trigger('call-ended', obj);
            if (!sess.fake) { //non-fake session
                if (sess.localStream)
                    sess.localStream.stop();
                this.removeVideo(sess);
            }
            this._freeLocalStreamIfUnused();
        } catch(e) {
            console.error("onTerminate() handler threw an exception:\n", e.stack?e.stack:e);
        }
    },

    _freeLocalStreamIfUnused: function() {
        if (Object.keys(this.jingle.sessions).length > 0)
            return;
//last call ended
        this._unrefLocalStream();
    },

    waitForRemoteMedia: function(playerElem, sess) {
        if (!this.jingle.sessionIsValid(sess))
            return;
        var self = this;
        if (playerElem[0].currentTime > 0) {
            this.onMediaRecv(playerElem, sess, sess.remoteStream);
            RTC.attachMediaStream(playerElem, sess.remoteStream); // FIXME: why do i have to do this for FF?
            // console.log('waitForremotevideo', sess.peerconnection.iceConnectionState, sess.peerconnection.signalingState);
        }
        else
            setTimeout(function () { self.waitForRemoteMedia(playerElem, sess); }, 200);
    },
//onRemoteStreamAdded -> waitForRemoteMedia (waits till time>0) -> onMediaRecv() -> addVideo()
    onRemoteStreamAdded: function(sess, event) {
        if ($(document).find('#remotevideo_'+sess.sid).length !== 0) {
            console.warn('Ignoring duplicate onRemoteStreamAdded for session', sess.sid); // FF 20
            return;
        }
        /**
         @event "remote-sdp-recv"
         @type {object}
         @property {string} peer The full JID of the peer
         @property {MediaStream} stream The remote media stream
         @property {SessWrapper} sess The call session
         */
        this.trigger('remote-sdp-recv', {peer: sess.peerjid, stream: event.stream, sess: new SessWrapper(sess)});
        var elemClass;
        var videoTracks = event.stream.getVideoTracks();
        if (!videoTracks || (videoTracks.length < 1))
            elemClass = 'rmtViewport rmtNoVideo';
        else
            elemClass = 'rmtViewport rmtVideo';

        this._attachRemoteStreamHandlers(event.stream);
        // after remote stream has been added, wait for ice to become connected
        // old code for compat with FF22 beta
        var elem = $("<video autoplay='autoplay' class='"+elemClass+"' id='remotevideo_" + sess.sid+"' />");
        RTC.attachMediaStream(elem, event.stream);
        this.waitForRemoteMedia(elem, sess); //also attaches media stream once time > 0

//     does not yet work for remote streams -- https://code.google.com/p/webrtc/issues/detail?id=861
//    var options = { interval:500 };
//    var speechEvents = hark(data.stream, options);

//    speechEvents.on('volume_change', function (volume, treshold) {
//      console.log('volume for ' + sid, volume, treshold);
//    });
    },

    onRemoteStreamRemoved: function(event) {
    },

    noStunCandidates: function() {
    },

    onJingleError: function(sess, err, stanza, orig) {
        if (err.source == 'transportinfo')
            err.source = 'transport-info (i.e. webrtc ice candidate)';
        if (!orig)
            orig = "(unknown)";

        if (err.isTimeout) {
            console.error('Timeout getting response to "'+err.source+'" packet, session:'+sess.sid+', orig-packet:\n', orig);
            /**
             @event "jingle-timeout"
             @type {object}
             @property {string} src A semantic name of the operation where the timeout occurred
             @property {DOM} orig The original XML packet to which the response timed out
             @property {SessWrapper} sess The session on which the timeout occurred
             */
            this.trigger('jingle-timeout', {src: err.source, orig: orig, sess: new SessWrapper(sess)});
        }
        else {
            if (!stanza)
                stanza = "(unknown)";
            console.error('Error response to "'+err.source+'" packet, session:', sess.sid,
                '\nerr-packet:\n', stanza, '\norig-packet:\n', orig);
            /**
             @event "jingle-error"
             @type {object}
             @property {string} src A semantic name of the operation where the error occurred
             @property {DOM} orig The XML stanza in response to which an error stanza was received
             @property {DOM} pkt The error XML stanza
             @property {SessWrapper} sess The session on which the error occurred
             */
            this.trigger('jingle-error', {src:err.source, pkt: stanza, orig: orig, sess: new SessWrapper(sess)});
        }
    },

    /**
     Get info whether local audio and video are being sent at the moment in a call to the specified JID
     @param {string} fullJid The <b>full</b> JID of the peer to whom there is an ongoing call
     @returns {{audio: Boolean, video: Boolean}} If there is no call to the specified JID, null is returned
     */
    getSentMediaTypes: function(fullJid)
    {
        var sess = this.jingle.jid2session[fullJid];
        if (!sess)
            return null;
//we don't use sess.mutedState because in Forefox we don't have a separate
//local streams for each session, so (un)muting one session's local stream applies to all
//other sessions, making mutedState out of sync
        var audTracks = sess.localStream.getAudioTracks();
        var vidTracks = sess.localStream.getVideoTracks();
        return {
            audio: (audTracks.length > 0) && audTracks[0].enabled,
            video: (vidTracks.length > 0) && vidTracks[0].enabled
        }
    },

    /**
     Get info whether remote audio and video are being received at the moment in a call to the specified JID
     @param {string} fullJid The full peer JID to identify the call
     @returns {{audio: Boolean, video: Boolean}} If there is no call to the specified JID, null is returned
     */
    getReceivedMediaTypes: function(fullJid) {
        var sess = this.jingle.jid2session[fullJid];
        if (!sess)
            return null;
        var m = sess.remoteMutedState;
        return {
            audio: (sess.remoteStream.getAudioTracks().length > 0) && !m.audioMuted,
            video: (sess.remoteStream.getVideoTracks().length > 0) && !m.videoMuted
        }
    },

    /**
     This is a <b>class</b> method (i.e. not called on an instance but directly on RtcSession).
     Registers a callback function that will be called
     repeatedly every 400 ms with the current mic volume level from 0 to 100%, once
     the local media stream is accessible. This can be called multiple times to change
     the callback, but only one callback is registered at any moment,
     for performance reasons.
     @static
     @param {VolumeCb} cb
     The callback function

     */
    volMonAttachCallback: function(cb)
    {
        RtcSession.gVolMonCallback = cb;
    },

    /**
     The volume level callback function
     @callback VolumeCb
     @param {int} level - The volume level in percent, from 0 to 100
     */
    _attachRemoteStreamHandlers: function(stream)
    {
        var at = stream.getAudioTracks();
        for (var i=0; i<at.length; i++)
            at[i].onmute =
                function(e) {
                    this.trigger('remote-audio-muted', stream);
                };
        var vt = stream.getVideoTracks();
        for (var i=0; i<vt.length; i++)
            vt[i].muted = function(e) {
                this.trigger('remote-video-muted', stream);
            };
    },
    _refLocalStream: function(sendsVideo) {
//    this._usesLocalStream = true;
        RtcSession.gLocalStreamRefcount++;
        if (sendsVideo)
            RtcSession._enableLocalVid(this);
    },
    _unrefLocalStream: function() {
//    if (!this._usesLocalStream)
//        return;

//    this._usesLocalStream = false;
        var cnt = --RtcSession.gLocalStreamRefcount;
        if (cnt > 0)
            return;

        if (!RtcSession.gLocalStream) {
            console.warn('RtcSession.unrefLocalStream: gLocalStream is null. refcount = ', cnt);
            return;
        }
        this._freeLocalStream();
    },
    _freeLocalStream: function() {
        RtcSession.gLocalStreamRefcount = 0;
        if (!RtcSession.gLocalStream)
            return;
        RtcSession._disableLocalVid(this);
        /**
         Local stream is about to be closed and local video player to be destroyed
         @event local-video-destroy
         @type {object}
         @property {DOM} player The local video player, which is about to be destroyed
         */
        this.trigger('local-player-remove', {player: RtcSession.gLocalVid});
        RtcSession.gLocalVid = null;
        RtcSession.gLocalStream.stop();
        RtcSession.gLocalStream = null;
    },

    trigger: function(name, obj) {
        if (this.logEvent)
            this.logEvent(name, obj);
        try {
            $(this).trigger(name, [obj]);
        } catch(e) {
            console.warn("Exception thrown from user event handler '"+name+"':\n"+e.stack?e.stack:e);
        }
    },
    /**
     Releases any global resources referenced by this instance, such as the reference
     to the local stream and video. This should be called especially if multiple instances
     of RtcSession are used in a single JS context
     */
    destroy: function() {
        this.hangup();
        this._freeLocalStream();
    },
    _requiredLocalStream: function(channels) {
        if (channels.video)
            return RtcSession.gLocalAudioVideoStream;
        else
            return RtcSession.gLocalAudioOnlyStream;
    }
};


RtcSession._maybeCreateVolMon = function() {
    if (RtcSession.gVolMon)
        return true;
    if (!RtcSession.gVolMonCallback || (typeof hark !== "function"))
        return false;

    RtcSession.gVolMon = hark(RtcSession.gLocalStream, { interval: 400 });
    RtcSession.gVolMon.on('volume_change',
        function (volume, treshold)
        {
            //console.log('volume', volume, treshold);
            var level;
            if (volume > -35)
                level = 100;
            else if (volume > -60)
                level = (volume + 100) * 100 / 25 - 160;
            else
                level = 0;
            RtcSession.gVolMonCallback(level);
        });
    return true;
};

RtcSession.mediaOptionsToMutedState =  function(options, stream) {
    var mutedState = new MutedState;
    var muteAudio = (!options.audio && (stream.getAudioTracks().length > 0));
    var muteVideo = (!options.video && (stream.getVideoTracks().length > 0));
    mutedState.set(muteAudio, muteVideo);
    return mutedState;
};

RtcSession.xmlUnescape = function(text) {
    return text.replace(/\&amp;/g, '&')
        .replace(/\&lt;/g, '<')
        .replace(/\&gt;/g, '>')
        .replace(/\&apos;/g, "'")
        .replace(/\&quot;/g, '"');
};

RtcSession._disableLocalVid = function(rtc) {
    if (!this._localVidEnabled)
        return;
// All references to local video are muted, disable local video display
// We need sess only to have where an object to trigger the event on
    RTC.attachMediaStream($(this.gLocalVid), null);
    /**
     Local camera playback has been disabled because all calls have muted their video
     @event local-video-disabled
     @type {object}
     @property {DOM} player - the local camera video HTML element
     */
    this._localVidEnabled = false;
    rtc.trigger('local-video-disabled', {player: this.gLocalVid});

};

RtcSession._enableLocalVid = function(rtc) {
    if(this._localVidEnabled)
        return;
    RTC.attachMediaStream($(this.gLocalVid), this.gLocalStream);
    /**
     Local video playback has been re-enabled because at least one call started sending video
     @event local-video-enabled
     @type {object}
     @property {DOM} player The local video player HTML element
     */
    rtc.trigger('local-video-enabled', {player: this.gLocalVid});
    this.gLocalVid.play();
    this._localVidEnabled = true;
};

/**
 Creates a unique string identifying the call,
 that is independent of whether the
 caller or callee generates it. Used only for sending stats
 */
RtcSession._makeCallId = function(sess) {
    if (sess.isInitiator)
        return sess.me+':'+sess.peerjid+':'+sess.sid;
    else
        return sess.peerjid+':'+sess.me+':'+sess.sid;
};

/**
 Session object
 This is an internal object, but the following properties are useful for the library user.
 @constructor
 */
function SessWrapper(sess) {
    this._sess = sess;
}

SessWrapper.prototype = {

    /**
     The remote peer's full JID
     @returns {string}
     */
    peerJid: function(){
        return this._sess.peerjid;
    },

    /**
     Our own JID
     @returns {string}
     */
    jid:function() {
        return this._sess.jid;
    },

    /**
     The stream object of the stream received from the peer
     @returns {MediaStream}
     */
    remoteStream: function() {
        return this._sess.remoteStream;
    },

    /**
     The Jingle session ID of this session
     @returns {string}
     */
    sid: function() {
        return this._sess.sid;
    },

    /**
     True if we are the caller, false if we answered the call
     @returns {boolean}
     */
    isCaller: function() {
        return this._sess.isInitiator;
    },

    /**
     True if this is a dummy session object and there was no established session before
     the call ended, or the session was closed before emitting the event.
     The object's peerJid() and isCaller() methods are guaranteed to return
     a meaningful value, sid() may or may not return a session id. The other
     getters will return <i>undefined</i>.
     This type of dummy session is passed only to the call-ended
     event handler, and this happens when an error occurred. The reason and text
     event properties carry more info about the error
     */
    isFake: function() {
        return (this._sess.isFake === true);
    }
};


RtcSession.xorEnc = function(str, key) {
    var int2hex = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];

    var result = "";
    var j = 0;
    var len = str.length;
    var keylen = key.length;
    for (var i = 0; i < len; ++i) {
        var code = str.charCodeAt(i) ^ key.charCodeAt(j++);
        if (j >= keylen)
            j = 0;
        result+=int2hex[code>>4];
        result+=int2hex[code&0x0f];
    }
    return result;
};

RtcSession.xorDec = function(str, key) {
    var result = "";
    var len = str.length;
    var j = 0;
    if (len & 1)
        throw new Error("Not a proper hex string");
    var keylen = key.length;
    for (var i=0; i<len; i+=2) {
        var code = (RtcSession.hexDigitToInt(str.charAt(i)) << 4)|
            RtcSession.hexDigitToInt(str.charAt(i+1));
        code ^= key.charCodeAt(j++);
        if (j >= keylen)
            j = 0;
        result+=String.fromCharCode(code);
    }
    return result;
};

RtcSession.hexDigitToInt = function(digit) {
    var code = digit.charCodeAt(0);
    if (code > 47 && code < 58)
        return code-48;
    else if (code > 96 && code < 103)
        return code-97+10;
    else if (code > 64 && code < 71)
        return code-65+10;
    else
        throw new Error("Non-hex char");
};
